/*
 * generated by Xtext 2.12.0
 */
package ai.ivex.specdsl.scoping

import ai.ivex.specdsl.specLang.AliasBlock
import ai.ivex.specdsl.specLang.EffectValueAssignment
import ai.ivex.specdsl.specLang.Model
import ai.ivex.specdsl.specLang.Predicate
import ai.ivex.specdsl.specLang.PredicateAlias
import ai.ivex.specdsl.specLang.SpecLangPackage
import ai.ivex.specdsl.specLang.ValueAssignment
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class SpecLangScopeProvider extends AbstractSpecLangScopeProvider {
	override getScope(EObject context, EReference reference) {
    	getScopeDispatch(context, reference)
	}
	
	def dispatch getScopeDispatch(ValueAssignment context, EReference reference){
		if (reference == SpecLangPackage.Literals.VALUE_ASSIGNMENT__VALUE){
			return Scopes.scopeFor(context.variable.values)
		}
		super.getScope(context, reference)
	}
	
	def dispatch getScopeDispatch(EffectValueAssignment context, EReference reference){
//		if (reference == SpecLangPackage.Literals.EFFECT_VALUE_ASSIGNMENT__VARIABLE){
//			val action = context.eContainer as Action
//			return Scopes.scopeFor(action.changeable.statevars)
//		}
		if (reference == SpecLangPackage.Literals.EFFECT_VALUE_ASSIGNMENT__VALUE)
			return Scopes.scopeFor(context.variable.values)
		super.getScope(context, reference)
	}
	
//	def dispatch getScopeDispatch(Action context, EReference reference){
//		if (reference == SpecLangPackage.Literals.EFFECT_VALUE_ASSIGNMENT__VARIABLE)
//			return Scopes.scopeFor(context.changeable.statevars)
//		super.getScope(context, reference)
//	}
	
	// Find all declared aliases when _not_ inside the alias block
	def dispatch getScopeDispatch(Predicate context, EReference reference){
		if (reference == SpecLangPackage.Literals.ALIAS_REFERENCE__PREDICATE_ALIAS){
			val aliasBlock = context.aliasBlock
			if(aliasBlock !== null){
				return Scopes.scopeFor(aliasBlock.aliases)
			}
		}
		super.getScope(context, reference)
	}
	
	
	// Find previously declared aliases while declaring a new alias in the alias block
	def dispatch getScopeDispatch(PredicateAlias context, EReference reference){
		if (reference == SpecLangPackage.Literals.ALIAS_REFERENCE__PREDICATE_ALIAS){
			val currentDecl = context.getRootAliasBlock
			var aliasBlock = currentDecl.eContainer as AliasBlock
			return Scopes.scopeFor(aliasBlock.aliases.takeWhile[it != currentDecl])
		}
		super.getScope(context, reference)
	}
	
	def dispatch getScopeDispatch(EObject context, EReference reference){
		super.getScope(context, reference)
	}
	
	def AliasBlock getAliasBlock(EObject context){
		var current = context
		while(! (current instanceof Model)){
			current = current.eContainer
		}
		return (current as Model).blocks.filter(AliasBlock).get(0)	
	}
	def getRootAliasBlock(EObject context){
		var current = context
		var parent = context.eContainer
		while(! (parent instanceof AliasBlock)){
			current = parent
			parent = parent.eContainer
		}
		return current		
	}
}
